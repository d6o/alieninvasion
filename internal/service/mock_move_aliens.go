// Code generated by MockGen. DO NOT EDIT.
// Source: move_aliens.go

// Package service is a generated GoMock package.
package service

import (
	context "context"
	reflect "reflect"

	model "github.com/d6o/alieninvasion/internal/model"
	gomock "github.com/golang/mock/gomock"
)

// MockcityNearbyRandomizer is a mock of cityNearbyRandomizer interface.
type MockcityNearbyRandomizer struct {
	ctrl     *gomock.Controller
	recorder *MockcityNearbyRandomizerMockRecorder
}

// MockcityNearbyRandomizerMockRecorder is the mock recorder for MockcityNearbyRandomizer.
type MockcityNearbyRandomizerMockRecorder struct {
	mock *MockcityNearbyRandomizer
}

// NewMockcityNearbyRandomizer creates a new mock instance.
func NewMockcityNearbyRandomizer(ctrl *gomock.Controller) *MockcityNearbyRandomizer {
	mock := &MockcityNearbyRandomizer{ctrl: ctrl}
	mock.recorder = &MockcityNearbyRandomizerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcityNearbyRandomizer) EXPECT() *MockcityNearbyRandomizerMockRecorder {
	return m.recorder
}

// CityFromCity mocks base method.
func (m *MockcityNearbyRandomizer) CityFromCity(city *model.City) *model.City {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CityFromCity", city)
	ret0, _ := ret[0].(*model.City)
	return ret0
}

// CityFromCity indicates an expected call of CityFromCity.
func (mr *MockcityNearbyRandomizerMockRecorder) CityFromCity(city interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CityFromCity", reflect.TypeOf((*MockcityNearbyRandomizer)(nil).CityFromCity), city)
}

// MockverifyFight is a mock of verifyFight interface.
type MockverifyFight struct {
	ctrl     *gomock.Controller
	recorder *MockverifyFightMockRecorder
}

// MockverifyFightMockRecorder is the mock recorder for MockverifyFight.
type MockverifyFightMockRecorder struct {
	mock *MockverifyFight
}

// NewMockverifyFight creates a new mock instance.
func NewMockverifyFight(ctrl *gomock.Controller) *MockverifyFight {
	mock := &MockverifyFight{ctrl: ctrl}
	mock.recorder = &MockverifyFightMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockverifyFight) EXPECT() *MockverifyFightMockRecorder {
	return m.recorder
}

// VerifyFight mocks base method.
func (m *MockverifyFight) VerifyFight(ctx context.Context, destinationCity *model.City) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "VerifyFight", ctx, destinationCity)
	ret0, _ := ret[0].(error)
	return ret0
}

// VerifyFight indicates an expected call of VerifyFight.
func (mr *MockverifyFightMockRecorder) VerifyFight(ctx, destinationCity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VerifyFight", reflect.TypeOf((*MockverifyFight)(nil).VerifyFight), ctx, destinationCity)
}
